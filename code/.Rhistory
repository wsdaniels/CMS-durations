# Read in simulation data
data <- readRDS('/Users/wdaniels/Documents/code/CMS-durations/input_data/case_study.RData')
View(data)
# Clear environment
if(!is.null(dev.list())){dev.off()}
rm(list = ls())
# Import necessary libraries
library(lubridate)
library(zoo)
library(scales)
# Source helper files which contain helper functions
source("/Users/wdaniels/Documents/papers/DLQ/code/HELPER_spike_detection_algorithm.R")
source("/Users/wdaniels/Documents/papers/duration_model/helper_functions.R")
# Read in simulation data
data <- readRDS('/Users/wdaniels/Documents/code/CMS-durations/input_data/case_study_forward_model_output.RData')
# Source helper files which contain helper functions
source("/Users/wdaniels/Documents/code/DLQ/code/HELPER_spike_detection_algorithm.R")
# Clear environment
if(!is.null(dev.list())){dev.off()}
rm(list = ls())
# Import necessary libraries
library(lubridate)
library(zoo)
library(scales)
# Source helper files which contain helper functions
source("/Users/wdaniels/Documents/code/DLQ/code/HELPER_spike_detection_algorithm.R")
# Clear environment
if(!is.null(dev.list())){dev.off()}
rm(list = ls())
# Import necessary libraries
library(lubridate)
library(zoo)
library(scales)
# Source helper files which contain helper functions
source("/Users/wdaniels/Documents/code/DLQ/code/HELPER_spike_detection_algorithm.R")
source("/Users/wdaniels/Documents/code/CMS-durations/code/helper_functions.R")
# Clear environment
if(!is.null(dev.list())){dev.off()}
rm(list = ls())
# Import necessary libraries
library(lubridate)
library(zoo)
library(scales)
# Source helper files which contain helper functions
source("/Users/wdaniels/Documents/code/DLQ/code/HELPER_spike_detection_algorithm.R")
source("/Users/wdaniels/Documents/code/CMS-durations/code/helper_functions.R")
# Read in simulation data
data <- readRDS('/Users/wdaniels/Documents/code/CMS-durations/input_data/case_study_forward_model_output.RData')
View(data)
# Pull out sensor observations and replace NA's that are not on edge of
# the time series with interpolated values
obs <- na.approx(data$obs, na.rm = F)
# Number of sensors
n.r <- ncol(obs)
# Pull out time stamps of observations and simulations
times <- data$times
# Pull out the simulation predictions
sims <- data[5:length(data)]
# Grab source info
n.s <- length(sims)
source.names <- names(sims)
# Define function to create a logarithmic spaced sequence (used later)
lseq <- function(from, to, length.out) {
exp(seq(log(from), log(to), length.out = length.out))
}
# Remove background from CMS observations
obs <- remove.background(obs,
going.up.threshold = 0.25, amp.threshold = 0.75,
gap.time = 30)
# Description: Performs emission event detection, localization, and quantification
#              using predictions from the Gaussian puff simulation
# Author: William Daniels (wdaniels@mines.edu)
# Last Updated: November 10, 2022
# Clear environment
if(!is.null(dev.list())){dev.off()}
rm(list = ls())
# Import necessary libraries
library(lubridate)
library(zoo)
library(scales)
# Source helper files which contain helper functions
source("/Users/wdaniels/Documents/code/DLQ/code/HELPER_spike_detection_algorithm.R")
source("/Users/wdaniels/Documents/code/CMS-durations/code/helper_functions.R")
# Read in simulation data
data <- readRDS('/Users/wdaniels/Documents/code/CMS-durations/input_data/case_study_forward_model_output.RData')
# Pull out sensor observations and replace NA's that are not on edge of
# the time series with interpolated values
obs <- na.approx(data$obs, na.rm = F)
# Number of sensors
n.r <- ncol(obs)
# Pull out time stamps of observations and simulations
times <- data$times
# Pull out the simulation predictions
sims <- data[5:length(data)]
# Grab source info
n.s <- length(sims)
source.names <- names(sims)
# Define function to create a logarithmic spaced sequence (used later)
lseq <- function(from, to, length.out) {
exp(seq(log(from), log(to), length.out = length.out))
}
# Remove background from CMS observations
obs <- remove.background(obs,
going.up.threshold = 0.25, amp.threshold = 0.75,
gap.time = 30)
# Create minute-by-minute maximum value time series across all CMS sensors
max.obs <- apply(obs, 1, max, na.rm = T)
# Identify spikes in the max.obs time series. These are the "naive events"
spikes <- perform.event.detection(max.obs, gap.time = 30, length.threshold = 15)
# Pull event "event numbers" that uniquely identify each naive event
event.nums <- na.omit(unique(spikes$events))
# Number of naive events
n.ints <- length(event.nums)
# Estimate source location for each naive event
loc.est.all.events <- perform.localization(spikes, obs, sims)
# Estimate emission rate for each naive event
all.q.vals <- perform.quantification(spikes, obs, sims, loc.est.all.events, print.report = T)
View(all.q.vals)
# Grab emission rate point estimate and 90% interval for each naive event from the MC output
rate.est.all.events <- sapply(all.q.vals, mean, na.rm = T)
error.lower.all.events <- sapply(all.q.vals, function(X) quantile(X, probs = 0.05, na.rm = T))
error.upper.all.events <- sapply(all.q.vals, function(X) quantile(X, probs = 0.95, na.rm = T))
# Scale simulations by the estimated emission rate for each naive event
sims <- scale.sims(sims)
# Create information mask based on simulated concentrations
info.list <- create.info.mask(sims)
# Get distribution of possible durations for each naive event
out <- get.durations(spikes = spikes, info.list = info.list, tz = "America/New_York")
View(out)
# Grab distribution of possible durations for each naive event
all.durations <- out$all.durations
View(all.durations)
# Grab distribution of possible durations for each naive event
all.durations <- out$all.durations
# Grab equipment-level duration distributions
est.durations <- out$est.durations
# Grab start time of naive events
event.starts <- out$event.starts
# Grab end time of naive events
event.ends <- out$event.ends
# Grab earliest possible start time for each naive event. The "start bounds"
start.bounds <- out$start.bounds
start.bonds
start.bounds
# Grab latest possible end time for each naive event. The "end bounds"
end.bounds <- out$end.bounds
View(out)
event.counts <- get.event.counts(spikes = spikes, info.list = info.list,
tz = "America/Denver")
View(event.counts)
total.time <- as.numeric(difftime(range(times)[2], range(times)[1], units = "days"))
# Scale event counts to annual-basis
num.events.per.year <- 365 * event.counts / total.time
num.events.per.year
# Get mean and 90% interval on emission frequencies for each equipment group
freq.mean <- apply(num.events.per.year, 2, mean)
freq.int <- apply(num.events.per.year, 2, function(X) quantile(X, probs = c(0.05, 0.95)))
frequency.results <- rbind(freq.mean, freq.int[1,], freq.int[2,])
print(t(round(frequency.results, 0))) # number of events per year
if (T){
for (t in 1:n.ints){
print(paste0(t, "/", n.ints))
par(mfrow = c(2,1))
par(mar = c(2,2,2,2))
this.mask <- seq(min(which(spikes$events == event.nums[t])),
max(which(spikes$events == event.nums[t])))
info.mask <- info.list[[which(names(info.list) == loc.est.all.events[t])]]
start.time <- spikes$time[this.mask][1]- hours(12)
end.time <- spikes$time[this.mask][length(this.mask)]+ hours(12)
to.plot <- source.names
if (loc.est.all.events[t] %in% to.plot){
ylim.vals <- c(event.nums[t] - 1, event.nums[t] + 1)
plot(data$times, spikes$events, pch = 19, xlim = c(start.time, end.time), ylim = ylim.vals,
col = NA, main = "")
mtext(loc.est.all.events[t], adj = 0)
abline(v = data$times[!is.na(info.mask$events)], col = alpha("royalblue", 0.25))
segments(x0 = spikes$time[this.mask], y0 = event.nums[t] - 0.25, y1 = event.nums[t] + 0.25)
for (tt in seq(1,n.ints)[-t]){
other.event.mask <- seq(min(which(spikes$events == event.nums[tt])),
max(which(spikes$events == event.nums[tt])))
segments(x0 = spikes$time[other.event.mask], y0 = event.nums[t] - 0.25, y1 = event.nums[t] + 0.25,
col = "gray44")
}
segments(x0 = start.bounds[t], y0 = event.nums[t] - 0.5, y1 = event.nums[t] + 0.5, col = "red", lwd = 2)
segments(x0 = end.bounds[t], y0 = event.nums[t] - 0.5, y1 = event.nums[t] + 0.5, col = "red", lwd= 2)
segments(x0 = spikes$time[this.mask], y0 = event.nums[t] - 0.25, y1 = event.nums[t] + 0.25)
xlim.vals <- c(0, ceiling(max(c(all.durations[[t]]))))
hist(all.durations[[t]], xlim = xlim.vals, main = t, breaks = seq(0,max(xlim.vals)))
abline(v = mean(all.durations[[t]]), col = "blue", lwd = 6)
abline(v = original.durations[t], col = "purple", lwd = 4)
}
}
}
# Calculate naive event durations
original.durations <- as.numeric(difftime(event.ends, event.starts, units = "hours"))
if (T){
for (t in 1:n.ints){
print(paste0(t, "/", n.ints))
par(mfrow = c(2,1))
par(mar = c(2,2,2,2))
this.mask <- seq(min(which(spikes$events == event.nums[t])),
max(which(spikes$events == event.nums[t])))
info.mask <- info.list[[which(names(info.list) == loc.est.all.events[t])]]
start.time <- spikes$time[this.mask][1]- hours(12)
end.time <- spikes$time[this.mask][length(this.mask)]+ hours(12)
to.plot <- source.names
if (loc.est.all.events[t] %in% to.plot){
ylim.vals <- c(event.nums[t] - 1, event.nums[t] + 1)
plot(data$times, spikes$events, pch = 19, xlim = c(start.time, end.time), ylim = ylim.vals,
col = NA, main = "")
mtext(loc.est.all.events[t], adj = 0)
abline(v = data$times[!is.na(info.mask$events)], col = alpha("royalblue", 0.25))
segments(x0 = spikes$time[this.mask], y0 = event.nums[t] - 0.25, y1 = event.nums[t] + 0.25)
for (tt in seq(1,n.ints)[-t]){
other.event.mask <- seq(min(which(spikes$events == event.nums[tt])),
max(which(spikes$events == event.nums[tt])))
segments(x0 = spikes$time[other.event.mask], y0 = event.nums[t] - 0.25, y1 = event.nums[t] + 0.25,
col = "gray44")
}
segments(x0 = start.bounds[t], y0 = event.nums[t] - 0.5, y1 = event.nums[t] + 0.5, col = "red", lwd = 2)
segments(x0 = end.bounds[t], y0 = event.nums[t] - 0.5, y1 = event.nums[t] + 0.5, col = "red", lwd= 2)
segments(x0 = spikes$time[this.mask], y0 = event.nums[t] - 0.25, y1 = event.nums[t] + 0.25)
xlim.vals <- c(0, ceiling(max(c(all.durations[[t]]))))
hist(all.durations[[t]], xlim = xlim.vals, main = t, breaks = seq(0,max(xlim.vals)))
abline(v = mean(all.durations[[t]]), col = "blue", lwd = 6)
abline(v = original.durations[t], col = "purple", lwd = 4)
}
}
}
est.durations <- vector(mode = "list", length = n.s)
names(est.durations) <- source.names
for (i in 1:length(all.durations)){
list.ind <- which(names(all.durations)[i] == source.names)
est.durations[[list.ind]] <- c(est.durations[[list.ind]], mean(all.durations[[i]]))
}
View(est.durations)
hist(est.durations$Production.Unit)
est.average.durations <- sapply(est.durations, mean)
est.min.interval <- sapply(est.durations, function(X) quantile(X, probs = 0.05))
est.max.interval <- sapply(est.durations, function(X) quantile(X, probs = 0.95))
# Get mean and 90% interval for each equipment group across all emission events
est.average.durations <- sapply(est.durations, mean)
est.min.interval <- sapply(est.durations, function(X) quantile(X, probs = 0.05))
est.max.interval <- sapply(est.durations, function(X) quantile(X, probs = 0.95))
par(mfrow = c(2,1))
par(mar = c(2,2,2,2))
for (i in 1:n.s){
breaks.max <- ceiling(max(est.durations[[i]], original.durations))
xlim.max <- 12
hist(est.durations[[i]], xlim = c(0,xlim.max), breaks = seq(0,breaks.max,0.5),
main = source.names[i], freq= F)
abline(v = mean(est.durations[[i]]), col = "royalblue", lwd= 3)
source.mask <- loc.est.all.events == source.names[i]
hist(original.durations[source.mask], xlim = c(0,xlim.max),
breaks = seq(0,breaks.max,0.5), main = "", freq = F)
abline(v = mean(original.durations[source.mask]), col = "purple", lwd= 3)
}
# Set colors for plots
tank.color <- "#3062CF" #blue
wellhead.east.color <- "#9147B8" #purple
separator.east.color <- "#7EAD52" #green
separator.west.color <- "#F1C30E" #gold
wellhead.west.color <- "#C7383C" #red
cols.for.hists <- c(wellhead.east.color, tank.color, wellhead.west.color, separator.west.color, separator.east.color)
par(mfrow = c(2,3))
par(mar = c(2,2,2,2))
xlim.max <- max(ceiling(sapply(est.durations, max)))+1
for (i in 1:n.s){
hist(est.durations[[i]], xlim = c(0,xlim.max), breaks = seq(0,xlim.max,2),
main = source.names[i], freq= F)
abline(v = mean(est.durations[[i]]), col = cols.for.hists[i], lwd= 3)
mtext(round(mean(est.durations[[i]]),2), side = 3, line = -1)
}
# Get start, mid, and end times for each event
event.start.times <- event.end.times <- event.mid.times <- vector(length = length(event.nums))
for (i in 1:length(event.nums)){
event.start.times[i] <- spikes$time[min(which(spikes$events == event.nums[i]))]
event.end.times[i]   <- spikes$time[max(which(spikes$events == event.nums[i]))]
event.mid.times[i]   <- mean(c(event.start.times[i], event.end.times[i]))
}
# Set plotting colors for estimated leak location data
rate.est.all.events.cols <- vector(length = n.ints)
rate.est.all.events.cols[loc.est.all.events == "Wellheads1"] <- wellhead.east.color
rate.est.all.events.cols[loc.est.all.events == "Wellheads2"] <- wellhead.west.color
rate.est.all.events.cols[loc.est.all.events == "Separator"] <- separator.west.color
rate.est.all.events.cols[loc.est.all.events == "Production.Unit"] <- separator.east.color
rate.est.all.events.cols[loc.est.all.events == "Tanks"] <- tank.color
plot.divs <- c(seq(min(times), max(times)+days(3), by = "5 days"))
axis.points <- seq(min(round_date(times, "day")-days(1)),
max(round_date(times, "day")+days(1)),
by = "day")
axis.labs <- paste0(month.abb[month(axis.points)],
"-", day(axis.points))
minor.axis.points <- seq(min(round_date(times, "day")-days(1)),
max(round_date(times, "day")+days(1)),
by = "6 hours")
png('/Users/wdaniels/Documents/papers/duration_model/figures/case_study_time_series_1.png',
res = 100, width = 1920, height = 1080, pointsize = 32)
dev.off()
dev.off()
par(mgp = c(2, 0.75, 0))
par(mar = c(1.5, 3.75, 0.5, 3.75))
par(mfrow = c(4,1))
for (i in 1:4){
ylim.max <- 8
plot(times, max.obs, col = "white",
ylim = c(0,ylim.max),
xlim = c(plot.divs[i], plot.divs[i+1]),
ylab = "",
yaxt = "n",
xlab = "",
xaxt= "n")
axis(side = 1, at = axis.points, labels = rep("", length(axis.points)), lwd = 4)
axis(side = 1, at = axis.points, labels = axis.labs, lwd = 0, line = -0.4)
axis(side = 1, at = minor.axis.points, labels = NA)
rect(xleft = event.start.times,
xright = event.end.times,
ybottom = 0, ytop = ylim.max,
col = alpha(rate.est.all.events.cols, 0.25))
lines(times, max.obs, col = "gray45")
points(event.mid.times, rate.est.all.events, pch = 19)
segments(x0 = event.mid.times,
y0 = error.lower.all.events,
y1 = error.upper.all.events,
lwd = 2)
mtext("Methane Concentration [ppm]", side = 2, outer = T, line = -1.25,
col = "gray45")
axis(side = 2, at = seq(0,8,by=2), col.axis = "gray45", col.ticks = "gray45")
mtext("Methane Emission Rate [kg/hr]", side = 4, outer = T, line = -1.25)
axis(side = 4, at = seq(0,8,by=2))
}
dev.off()
dev.off()
duration.out <- list(all.durations = all.durations)
View(duration.out)
duration.out <- list(all.durations = all.durations,
est.durations = est.durations)
View(spikes)
View(info.list)
duration.out <- list(all.durations = all.durations,
est.durations = est.durations,
info.list = info.list,
spikes = spikes,
rate.est.all.events = rate.est.all.events
)
View(duration.out)
duration.out <- list(all.durations = all.durations,
est.durations = est.durations,
info.list = info.list,
spikes = spikes,
rate.est.all.events = rate.est.all.events,
loc.est.all.events = loc.est.all.events
)
duration.out <- list(all.durations = all.durations,
est.durations = est.durations,
info.list = info.list,
spikes = spikes,
rate.est.all.events = rate.est.all.events,
loc.est.all.events = loc.est.all.events
)
saveRDS(duration.out, file = "/Users/wdaniels/Documents/code/output_data/duration_estimates.RData")
duration.out <- list(all.durations = all.durations,
est.durations = est.durations,
info.list = info.list,
spikes = spikes,
rate.est.all.events = rate.est.all.events,
loc.est.all.events = loc.est.all.events
)
saveRDS(duration.out, file = "/Users/wdaniels/Documents/code/CMS-durations/output_data/duration_estimates.RData")
duration.out <- list(all.durations = all.durations,
est.durations = est.durations,
info.list = info.list,
spikes = spikes,
rate.est.all.events = rate.est.all.events,
loc.est.all.events = loc.est.all.events,
source.names = source.names
)
saveRDS(duration.out, file = "/Users/wdaniels/Documents/code/CMS-durations/output_data/duration_estimates.RData")
duration.out <- list(all.durations = all.durations,
est.durations = est.durations,
info.list = info.list,
spikes = spikes,
rate.est.all.events = rate.est.all.events,
loc.est.all.events = loc.est.all.events,
source.names = source.names
)
saveRDS(duration.out, file = "/Users/wdaniels/Documents/code/CMS-durations/output_data/duration_estimates.RData")
data$times == spikes$time
all(data$times == spikes$time)
duration.out <- list(all.durations = all.durations,
est.durations = est.durations,
start.bounds = start.bounds,
end.bounds = end.bounds,
info.list = info.list,
spikes = spikes,
rate.est.all.events = rate.est.all.events,
loc.est.all.events = loc.est.all.events,
source.names = source.names
)
saveRDS(duration.out, file = "/Users/wdaniels/Documents/code/CMS-durations/output_data/duration_estimates.RData")
duration.out <- list(all.durations = all.durations,
est.durations = est.durations,
start.bounds = start.bounds,
end.bounds = end.bounds,
original.durations = original.durations,
info.list = info.list,
spikes = spikes,
rate.est.all.events = rate.est.all.events,
loc.est.all.events = loc.est.all.events,
source.names = source.names
)
saveRDS(duration.out, file = "/Users/wdaniels/Documents/code/CMS-durations/output_data/duration_estimates.RData")
duration.out <- list(all.durations = all.durations,
est.durations = est.durations,
start.bounds = start.bounds,
end.bounds = end.bounds,
original.durations = original.durations,
info.list = info.list,
spikes = spikes,
max.obs = max.obs,
rate.est.all.events = rate.est.all.events,
loc.est.all.events = loc.est.all.events,
source.names = source.names
)
saveRDS(duration.out, file = "/Users/wdaniels/Documents/code/CMS-durations/output_data/duration_estimates.RData")
duration.out <- list(all.durations = all.durations,
est.durations = est.durations,
start.bounds = start.bounds,
end.bounds = end.bounds,
original.durations = original.durations,
info.list = info.list,
spikes = spikes,
max.obs = max.obs,
rate.est.all.events = rate.est.all.events,
error.lower.all.events = error.lower.all.events,
error.upper.all.events = error.upper.all.events,
loc.est.all.events = loc.est.all.events,
source.names = source.names
)
duration.out <- list(all.durations = all.durations,
est.durations = est.durations,
start.bounds = start.bounds,
end.bounds = end.bounds,
original.durations = original.durations,
info.list = info.list,
spikes = spikes,
max.obs = max.obs,
rate.est.all.events = rate.est.all.events,
error.lower.all.events = error.lower.all.events,
error.upper.all.events = error.upper.all.events,
loc.est.all.events = loc.est.all.events,
source.names = source.names)
saveRDS(duration.out, file = "/Users/wdaniels/Documents/code/CMS-durations/output_data/duration_estimates.RData")
# Description: Estimate emission durations using CMS, accounting for
#              CMS non-detect times.
# Author: William Daniels (wdaniels@mines.edu)
# Last Updated: May 1, 2024
# Clear environment
if(!is.null(dev.list())){dev.off()}
rm(list = ls())
# Import necessary libraries
library(lubridate)
library(zoo)
library(scales)
duration.estimates <- readRDS('/Users/wdaniels/Documents/code/CMS-durations/output_data/duration_estimates.RData')
all.durations <- duration.estimates$all.durations
est.durations <- duration.estimates$est.durations
info.list <- duration.estimates$info.list
spikes <- duration.estimates$spikes
rate.est.all.events <- duration.estimates$rate.est.all.events
loc.est.all.events <- duration.estimates$loc.est.all.events
source.names <- duration.estimates$source.names
# Pull event "event numbers" that uniquely identify each naive event
event.nums <- na.omit(unique(spikes$events))
# Number of naive events
n.ints <- length(event.nums)
# STEP 6: PLOT EVENTS AND EVENT-LEVEL DURATION DISTRIBUTIONS
#---------------------------------------------------------------------------
if (T){
for (t in 1:n.ints){
print(paste0(t, "/", n.ints))
par(mfrow = c(2,1))
par(mar = c(2,2,2,2))
this.mask <- seq(min(which(spikes$events == event.nums[t])),
max(which(spikes$events == event.nums[t])))
info.mask <- info.list[[which(names(info.list) == loc.est.all.events[t])]]
start.time <- spikes$time[this.mask][1]- hours(12)
end.time <- spikes$time[this.mask][length(this.mask)]+ hours(12)
to.plot <- source.names
if (loc.est.all.events[t] %in% to.plot){
ylim.vals <- c(event.nums[t] - 1, event.nums[t] + 1)
plot(spikes$time, spikes$events, pch = 19, xlim = c(start.time, end.time), ylim = ylim.vals,
col = NA, main = "")
mtext(loc.est.all.events[t], adj = 0)
abline(v = spikes$time[!is.na(info.mask$events)], col = alpha("royalblue", 0.25))
segments(x0 = spikes$time[this.mask], y0 = event.nums[t] - 0.25, y1 = event.nums[t] + 0.25)
for (tt in seq(1,n.ints)[-t]){
other.event.mask <- seq(min(which(spikes$events == event.nums[tt])),
max(which(spikes$events == event.nums[tt])))
segments(x0 = spikes$time[other.event.mask], y0 = event.nums[t] - 0.25, y1 = event.nums[t] + 0.25,
col = "gray44")
}
segments(x0 = start.bounds[t], y0 = event.nums[t] - 0.5, y1 = event.nums[t] + 0.5, col = "red", lwd = 2)
segments(x0 = end.bounds[t], y0 = event.nums[t] - 0.5, y1 = event.nums[t] + 0.5, col = "red", lwd= 2)
segments(x0 = spikes$time[this.mask], y0 = event.nums[t] - 0.25, y1 = event.nums[t] + 0.25)
xlim.vals <- c(0, ceiling(max(c(all.durations[[t]]))))
hist(all.durations[[t]], xlim = xlim.vals, main = t, breaks = seq(0,max(xlim.vals)))
abline(v = mean(all.durations[[t]]), col = "blue", lwd = 6)
abline(v = original.durations[t], col = "purple", lwd = 4)
}
}
}
